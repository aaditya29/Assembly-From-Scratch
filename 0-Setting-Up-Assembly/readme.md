# How to Use ARM64 Assembly on Mac M1

> Here we would create a hello world application in ARM assembly for Apple silicon.

## Step 1: Command Line Tool Installation

We're going to make sure that we have xcode or command line tools installed on our machine.

```Shell
xcode-select --install
```

## Step 2: Building `Hello.c` File

Before we start writing some assembly code what we're going to do is create that exact same hello world application in C. The reason we're going to do it in C is because it's very close to the assembly and therefore the concepts that we're going to introduce as we write back code is going to be easier to translate if we understand what's happening in C first.

```Shell
touch hello.c
code .

```

And now we write a hello world program in C

```C
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}

```

If we want to compile this we can do this in multiple ways. If we want to use GCC then we can install that by doing

```Shell
brew install GCC
```

And then compile

```Shell
gcc hello.c -o hello
```

Where -o means that it's going to create an output file and that output file is going to be the same name of our executable so in this case it's going to be hello.<br>
Now we run it:

```Shell
./hello
```

Alternatively we can use the CLang too:

```Shell
clang hello.c -o hello
ls
./hello
```

Now we have the C compiler which can be clang or GCC and what it's going to do is actually compile our underline files hello.c and then it's going to do that compilation and then it's going to create what's known as an intermediate object file.

We need to be able to link inbuilt system libraries together and that's where a Linker comes in place. The Linker is gonna take any libraries that we need to link them together so that when we're referencing any sort of global or external functions and it's going to build together and then we're going to have that outputted executable.<br>
So if we didn't have this sort of linking step in between we wouldn't know where those system libraries are and we won't be able to use this sort of standard uh Linux output calls or Unix output calls.

In order to generate that object file we will do following steps:

```Shell
clang hello.c -c -o hello.o
```

$Where$

- `clang` is invoked to compile the hello.c source file.
- The `-c` option tells clang to generate an object file (hello.o) from hello.c.
- The `-o hello.o` option specifies that the output object file should be named hello.o.

Followed by linking process

```Shell
ld hello.o -o hello
```

$Where$

- `ld` is the GNU linker. It is used to link object files together to create an executable or library. In this context, ld is being invoked to link the hello.o object file.
- `hello.o` is the input object file that will be linked by ld. The linker (ld) takes one or more object files as input and resolves references between them to produce a single executable file.
- `o hello` specifies the output file name for the executable that will be generated by the linker (ld). The -o option is used to specify the name of the output file. In this case, the output executable file will be named hello.

Now we are going to type

```Shell
xcrun -sdk macosx --show-sdk-path
```

Which is going to come back with the location of that SDK and that's going to have all the libraries that we need to be able to do with our linking .

Now to link with standard function we are going to type

```Shell
ld hello.o -o hello -l System -syslibroot `xcrun -sdk macosx --show-sdk-path` -e _main -arch arm64
```

$Where$

- `ld` is the GNU linker, used to link object files together to create an executable or library.
- `hello.o` is the input object file that will be linked by ld. It contains the compiled machine code from your source file hello.c.
- `-o` hello specifies the output file name for the executable that will be generated by the linker (ld). The -o option is used to specify the name of the output file. Here, the output executable file will be named hello.
- `-l System` tells the linker (ld) to link against a system library named System. System libraries provide pre-written code that our program can use, such as functions for interacting with the operating system.
- `-syslibroot xcrun -sdk macosx --show-sdk-path` specifies the root directory for system libraries and headers using the result of the command `xcrun -sdk macosx --show-sdk-path`.
- `xcrun -sdk macosx --show-sdk-path` command (xcrun) is used to locate and print the path to the macOS SDK (Software Development Kit). The `--show-sdk-path` option specifies that we want the path to the SDK for macOS.
- The `backticks` around the command indicate command substitution in the shell, meaning that the result of the command inside the backticks will be used as part of the `ld` command.
- `-e _main` specifies the entry point (or starting point) of the program. Here, \_main indicates that the program should start execution from the \_main function.
- `-arch arm64` specifies the target architecture for which the executable will be built. In this case, arm64 refers to the ARM 64-bit architecture commonly used in Apple Silicon (M1) processors.

## Step 3: Building `Hello.s` Assembly File

Now we create a `Hello.s` assembly file

```Shell
touch hello.s
```

And install ARM Assembly Extension on VS Code.

Now we code a Hello World Assembly Program

```Assembly
//
//hello world
//

.global _start
.align 2


//main

_start:
    b _printf
    b _terminate //branch

_printf:
    mov X0, #1//stdout
    adr X1, helloworld //address of hello world string
    mov X2, #12 //length of hello world string
    mov X16, #4 //write to stdout
    svc 0//syscall


_terminate:
    mov X0, #0
    mov X16, #1
    svc 0//syscall

helloworld: .ascii "Hello World\n"
```
